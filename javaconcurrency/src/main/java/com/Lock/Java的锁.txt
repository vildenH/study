公平和非公平锁：
    公平锁指的是多个线程在等待一个锁时是按照申请锁的先后顺序来一次获得锁。而非公平锁则可能是发生抢占，后来的申请锁的线程可以先行抢占锁，整体效率较高，但是可能导致有些先来的线程发生饥饿等待的情况。
    在Java当中，ReentrantLock实现了公平锁和非公平锁。

自旋锁：
    Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态装换需要耗费很多的处理器时间，对于代码简单的同步块（如被synchronized修饰的getter()和setter()方法），状态转换消耗的时间有可能比用户代码执行的时间还要长。
    虚拟机的开发团队注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间取挂起和恢复现场并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下“，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。
    自旋锁也是一种乐观锁，但是不能代替阻塞，自旋等待本身虽然避免了线程切换的开销，但是自旋的过程需要占用处理的时间，所以在自旋时间很短的情况，自旋等待的效果就很好，但是当锁占用时间很长的时候，自旋的线程只会拜拜浪费处理器资源。因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当使用传统的方式去挂起线程了。

死锁：
    死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，他们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足一下4个条件：

    互斥条件：一个资源每次只能被一个进程使用。
    请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
    不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。
    循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
    避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序做操作来避免死锁。

锁消除:


锁粗化:
