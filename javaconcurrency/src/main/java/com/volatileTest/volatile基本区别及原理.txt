为什么要使用volatile？
    在当前的Java内存模型下，线程可以把变量保存在本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。
    要解决这个问题，只需要像在本程序中的这样，把该变量声明为volatile（不稳定的）即可，这就指示JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。
    一般说来，多任务环境下各任务间共享的标志都应该加volatile修饰。

Volatile成员变量的特点？
    被volatile修饰的变量，每次被线程访问的时候，都会从共享内存中重读该成员变量的值，并且在成员变量发生变化的时候，都会将变化值写回到共享内存，这样的结果在任何时刻，两个不同的线程总是能读到成员变量的同一个值。
    可以说，volatile主要维护了并发编程中的可见性问题。但是不能保证并发编程中的原子性的问题。

volatile使用场景:
    由于volatile较为轻量级，在某些情况下性能将会优于synchronized。但是由于无法保证操作的原子性。使用volatile需要具备以下两个条件。
    1.对变量的写操作不依赖于当前值
    2.该变量没有包含在具有其他变量的不变式中 ？？？

    主要使用场景用：
    1.状态标记量

volatile是如何保证内存可见性的？
    内存屏障:
    禁止指令重排


Java并发编程中原子性问题解决方法？
    1.synchronized
    2.采用Lock，ReentranLock
    3.AtomicInteger


    synchronized与Lock的区别？

happen-before是什么概念？解决什么问题？
    Java程序经过编译后会被编译器和处理器进行优化以提高运行效率，其中会使用一种优化技术"重排序"，重排序需要遵守的一个规则，叫做"happen-before"
